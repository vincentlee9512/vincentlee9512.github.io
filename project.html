<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Vincent Li</title>

  <link href="css/bootstrap.min.css" type="text/css" rel="stylesheet">
  <link href="css/style.css" type="text/css" rel="stylesheet">
</head>
<body>
  <div class="container">
    <div id="lang_preference">
      <h5 style="font-weight: bold">李文轩 Wenxuan Li (Vincent)</h5>
      <p>language preferrence (语言偏好）: &nbsp;&nbsp;
        <span id="eng_site"><a href="project_en.html">English</a>&nbsp;&nbsp;</span>
        <span id="cn_site">中文</span>
      </p>
    </div>
    <div id="nav">
      <ul class="nav nav-tabs">
        <li class="nav-item">
          <a class="nav-link" href="index.html">主页</a>
        </li>
        <li class="nav-item">
          <a class="nav-link  active" href="project.html">项目</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="resume.html">简历</a>
        </li>
      </ul>
    </div>


    <div id="content">
        <div>
            <h4 class='dark_red'>项目</h4>

            <br/>

            <h6>2019年 7月 29日</h6>
            <h6>人际关系分析：PageRank算法</h6>
            <p>
                （个人项目）这个项目通过使用 Python 的第三方库 NetworkX 中的有向图类和 pagerank 函数，
                对邮件中的寄件人和收件人进行分析，最后用分析的数据绘制数据可视化图表。
            </p>
            <p>
                这个项目分为三个核心部分，分别是数据加载、数据准备、和数据挖掘。
            </p>
            <p>
                第一部分是加载数据。这个项目中，我用来希拉里公开的邮件作为数据(https://www.kaggle.com/kaggle/hillary-clinton-emails)；
                全部数据都以 csv 格式储存。
                整个项目中，emails.csv 储存着核心数据；里面的每一封邮件的寄件人和收件人信息是分析这些邮件中的人际关系的基本数据。
                Persons.csv 和 aliases.csv 储存着相关的人名和别名；在统一寄件人和收件人的人名时需要用到。
            </p>
            <p>
                第二部分是数据准备。这个阶段中，我将上一个阶段中加载的所有数据过滤成需要的形式。
                在 emails.csv 的数据中，因为邮件本文不在考虑范围内，我只提取了寄件人和收件人的信息，并计算了每个人的邮件来往次数；
                这个次数将会被用在之后的有向图中，作为权重。而 Persons.csv 和 aliases.csv 将会被用在统一人名的步骤中。
            </p>
            <p>
                第三部分是数据挖掘。这个阶段中，我使用 NetworkX 库中的有向图类和 pagerank 函数对过滤后的数据进行分析。
                我把计算好的边和权重作为参数，构建了有向图类。然后使用 pagerank 函数计算有向图中所有节点的 pr 值。
                在绘制图表前，我根据 pr 值大小设置节点的大小，并把过小的节点去掉，提升可读性。
            </p>
            <p>
                Github 链接: <a href="https://github.com/vincentlee9512/personal_relationship_in_email" target="_blank ">Project Repository</a>
            </p>
            <br/>

            <h6>2019年 7月 26日</h6>
            <h6>文档分类：多项式朴素贝叶斯分类器</h6>
            <p>
                (个人项目）这个项目通过使用 scikit-learn(sklearn) 库的多项式朴素贝叶斯算法，创建了一个中文文档的分类器。
            </p>

            <p>
                在这个项目分为两个核心部分，分别是数据准备和文档分类。
            </p>

            <p>
                在数据准备部分，程序会加载事先下载好的训练集和测试集，并且用 jieba 库对这些文档进行分词。
                然后，程序会加载停用词集并将其转化为数组；
                接着程序会使用 sklearn 库的 TfidfVectorizer 类计算单词 TF-IDF 向量的值；创建这个对象时，传入停用词集。
                调用这个对象的 fit_transform 函数对训练集进行拟合，得到训练集的特征空间。
            </p>

            <p>
                在文档分类部分，我用了 sklearn 库里的 MultinomialNB 类创建了多项式朴素贝叶斯分类器。
                然后调用这个分类器的 fit 函数，传入上面的训练集的特征空间和对应的分类（labels）作为参数；
                这个分类器会自动训练成一个符合特征空间和对应分类的分类器。
                获得训练好的分类器后，我传入测试集做预测，并计算分类器的准确率。
            </p>

            <p>
                Github 链接: <a href="https://github.com/vincentlee9512/docs_classifier" target="_blank ">Project Repository</a>
            </p>

            <br/>


            <h6>2019年 7月 25日</h6>
            <h6>数据可视化：歌词收集和词云可视化</h6>
            <p>
                (个人项目）这是一个数据可视化的练习项目。通过分析数据携带的常用词，做词云展示。项目中的数据来自网易云音乐的API。
            </p>

            <p>
                在这个项目分为两个核心部分，分别是数据准备和词云分析。
            </p>

            <p>
                在数据准备部分，我首先用 request 库和网易云音乐的歌手 id，抓取了此歌手的前 50 首热门单曲。
                然后通过 xpath 解析返回数据中的 html 并获得前 50 首热门单曲的名字和id。
                接着用歌曲 id 和网易歌词的API（'http://music.163.com/api/song/lyric?os=pc&id=' + song_id + '&lv=-1&kv=-1&tv=-1'），
                抓取歌单中歌曲的歌词。在获取歌词后，我使用了停用词集对歌词进行过滤，并且用 jieba 库对歌词集进行分词。
            </p>

            <p>
                在词云分析阶段，我使用了 WordCloud 库解析过滤后的歌词，并生成词云。最后调用 matplotlib 里的 pyplot 展示词云。
            </p>

            <p>
                Github 链接: <a href="https://github.com/vincentlee9512/lyrics_cloud" target="_blank ">Project Repository</a>
            </p>

            <br/>

            <h6>2019年 5月 22日：</h6>
            <h6>Minnesota Geological Survey 项目</h6>
            <p>
                （小组项目：毕业设计）全班一起帮助明尼苏达州当地地质信息收集组织MGS（Minnesota Geological Survey)更新、维护与开发一系列地质信息收集的软件。
                整个MGS项目分为五个组，分别为维护小组、数据库小组、DevOps组、新桌面软件开发小组和移动开发小组。
            </p>
            <p>
                在这个项目的第一阶段里，我在维护小组对MGS原本的桌面软件进行了维护，包括整理代码，编写注解和Debug。此软件在2004年由原本MGS的技术开发人员用Visual Basic 与 Esri 的 ArcGIS 所开发。
                我的主要任务是通过整理代码和编写注解，提高代码的可读性和让同项目的其他人员更加了解此项目。
                在此阶段，我定位及修改了一个关于百分比计算不正确的漏洞。此漏洞出现在填写地质信息的表格中，在用户填入地质信息时，表格中自动计算的各项占比（百分比）出现异常。
                此漏洞出现在我所负责整理的代码中。在于同组组员商量后，进行了百分比算法的改进。
            </p>
            <p>
                在这个项目的第二阶段里，因为维护小组的任务逐渐减少，所以我被重新分配到移动开发小组进行MGS新的IOS软件开发。
                这个新的App应用是为了让地质学家们在现场用IOS设备记录下他们所得到的地质信息。
                因为很多实地考察是没有网络连接的，所以这个应用允许地质学家线下使用；在获得网络连接之后再上传到数据库。
                在移动开发小组里，我主要负责小组任务进程管理、报告及文档的编写、协助开发App的核心功能、开发App的非核心功能。
                因为整个项目都是用Github作为版本管控和代码传输，所以在此阶段中，我用Github中自带的 Issues 和 Projects 功能，管理和分派任务。
                在代码的提交上，我提出并落实了用 Github 的 Pull requests 来审查组员所提交的代码。
                在版本管理上，我采用了 Git Flow 的工作流改善了原本版本更新的做法。
                具体改变是，每个人所负责的不同功能的开发，都会在Git仓库里有不同的分支。在完成具体功能的开发后，通过 Pull requests 从功能开发分支提交到主开发分支上。
                在每个开发周期（两周）结束时，再由主开发分支提交到发布分支上。
            </p>

            <p>
                在项目的最后阶段里，我负责移动开发小组的文档编写工作（下列的移动开发小组文档，与部分的移动开发小组报告）。
            </p>

            <p>
                <br/>
                - <a href="src/QDI_Class_Overview.pdf" target="_blank">项目概观（PDF）</a> <br/>
                - <a href="src/QDI_Mobile_Final_Report.pdf" target="_blank">移动开发小组报告（PDF）</a> <br/>
                - <a href="src/QDI_Mobile_Final_Documentation.pdf" target="_blank">移动开发小组文档（PDF）</a>
            </p>
            <br/>

            <h6>2018年 12月 10日：</h6>
            <h6>计算机系统结构：缓存模拟器</h6>
            <p>
                (小组项目）在这个项目中，James Allender 和我一起实现了一个课内自定义的CPU缓存模拟器。
                这个模拟器是用C语言开发的。
                这个CPU缓存模拟器的目的是模拟缓存在计算机系统中，是如何处理拦截处理器和内存之间的请求和处理内存的读写的事务的。
                这个缓存模拟器的储存大小是由用户的所提供的参数所决定的，参数本身也有一定的范围；这些参数包括了字每块、组数和相联度。
                相联度的范围是从 1 (直接映射，direct-mapped cache）到缓存的块数（全关联，full associative cache）。
                块的大小决定了一次性在内存能够读写多少字（word）。另一方面，我们采用写回机制（write back policy），
                即不直接写会内存；若目标地址已经存在于缓存内，直接写进缓存，若不在缓存，先从内存读入所需地址的数据，再写入缓存。
                待到此块数据必须被替换或被失效时，才写回内存。
            </p>

            <p>
                在处理读入数据的请求时，这个程序会先检查目标数据已经在缓存中。如果已经存在，直接从缓存中取数据。
                如果不存在，它会在内存中取到目标数据，并把它替换到缓存里的LRU（Least Recently Used, 最近最少使用）的块中。
            </p>

            <p>
                在处理写出数据的请求时，这个程序会运行和读入数据时相似的行为；程序会先在缓存中找，数据所在的地址是否已经被读入。
                如果此段地址存在于缓存中，它会直接把从处理器传来的新的数据直接写在和内存地址相应的缓存块中。如果此段地址不存在
                于缓存中，这个程序会先从内存中读取这段地址的数据，然后把新的数据写进这个块中；这段新的数据并不会直接写回内存中。
            </p>

            <p>
                在这个程序即将中止时，即模拟器接收到停止（halt）命令时，缓存会遍历其中到所有块，检查他们是否有效和是否有改变。
                所有有效且被改变过的块，都会将最新的数据写进内存。
            </p>

            <p>
                在这个项目中，我主要负责的是与我的组员一起设计缓存在C语言里的结构和独立完成缓存模拟器的处理读取数据的能力。
            </p>

            <br/>
            <p>
                Github 链接: <a href="https://github.com/vincentlee9512/cisc340_project4_selfcopy" target="_blank ">Project Repository</a>
            </p>

            <br/>
            <h6>2018年 11月 20日：</h6>
            <h6>计算机系统结构：流水线数据通路模拟器</h6>
            <p>
                (小组项目）在这个项目中，James Allender 和我一起实现了一个课内自定义的流水线数据通路的模拟器。
                这个模拟器是由C语言开发的。
                这个流水线数据通路模拟器的目的是模拟计算机执行机器代码时的正确行为；这个程序会在每个周期打印出机器的状态，
                还会在执行完命令后，打印出相关的统计数据。
            </p>

            <p>
                整个模拟器主要是由流水线上 5 个阶段的行为和处理冒险的方法组成的（控制冒险和数据冒险）。
                在我们的自定义的流水线数据通路模拟器中，流水线对处理命令有 5 个阶段；他们分别是取指阶段（IF，Instruction Fetch）,
                译码阶段或者读取阶段（ID，Instruction Decode, or register file read），执行阶段（Ex，execution），存储器访问阶段
                （MEM，memory access），和写回阶段（WB，write back）。在取指阶段，程序会读取内存中指针所指向对下一条机器代码。
                在译码阶段或者读取阶段，程序会读译取指阶段读到的那条机器代码，并在指定寄存器中读取执行阶段所需数据。在执行阶段，程序模拟
                处理器执行机器代码。在存续器访问阶段，模拟处理器在存储器（内存）上读或写。最后写回阶段，若需要，将执行结果写回到指定的寄
                存器。这流水线上的处理机器代码命令的 5 个阶段，我们都在我们的程序中写成了独立的函数。这些函数都会在每个周期逐个被独自调用。
            </p>

            <p>
                在各个阶段之间和最后的写回阶段之后，我们都设立了不同的缓冲区。这些缓冲区会在每个周期之间，被用作储存上一个阶段的输出的暂存器。
                在每个周期开始的时候，每个阶段都会在前一个缓冲区读入数据；然后在每个周期结束前，每个阶段也会将输出的数据写入后一个缓冲区。
                在我们的设计中，因为所有阶段，理论上来说，都是同时进行的而不是时序性的，所以当前的各个阶段的行为都不会影响当前计算机的状态
                （current state），每个阶段都会输出到一个暂时的新的状态（new state），这样可以轻易解决新久状态的混淆问题。在周期结束前
                一步，新的状态将替代原来的状态，然后 计算机进入下一个周期。简单来说，各个阶段将从当前的计算机状态里的缓冲区读取数据，然后
                处理完毕后，输出到新的状态中的缓冲区。
            </p>

            <p>
                这个流水线数据通路的设计中，会出现控制冒险和数据冒险。 在处理数据冒险上，我们的想法是在当前周期的执行阶段时，检查执行阶段
                后的所有的缓冲区是否有与执行阶段冲突的数据。一个名叫 hasDataHazard 的函数主要是在指定的缓冲区侦测数据冒险。一个名叫
                forwarding（前推）的函数会通过多次调用 hasDataHazard 函数来检查数据冒险。如果在这些缓冲区中存在数据冒险，处理器会在
                执行阶段里直接提取最新的数据并运用在执行中。如果没有数据冒险，这个函数不会采取任何动作。
            </p>

            <p>
                在处理控制冒险的情况是，每当我们取指取到一条 BEQ（branch on equal, 等则分支）命令时，我们采取的是先预测此命令不等
                （在这个模拟器的设计中，只有等则分支，没有不等则分支）。如果这条 BEQ 命令到达来存储器访问阶段并且结果是相等的话，这个
                程序会将存储器访问阶段前的所有缓冲区改为空指令（No-operation）并且将命令指针移动到分支的目标处。
            </p>

            <p>
                在这个项目中，我主要负责的是开发取指阶段、译码阶段或者读取阶段、和写回阶段；以及所有处理数据冒险的解决方案，包括了前推和
                数据冒险检查的函数。
            </p>
                <br/>
            <p>
                Github 链接: <a href="https://github.com/vincentlee9512/cisc340_project3_selfcopy" target="_blank ">Project Repository</a>
            </p>

            <br/>
            <h6>2018年 10月 30日：</h6>
            <h6>计算机系统结构：性能分析</h6>
            <p>
                （小组项目）在这个项目里，Lucy Post 和我一起分析了单周期 CPU 和多周期 CPU的性能不同之处。
                我们基于上一个项目中的行为模拟器，创建了一个多周期 CPU 设计的模拟器；而上一个项目里的模拟器是单周期设计的。
            </p>
            <p>
                在这个项目中，改造模拟器和性能分析的部分都是由我们两个人一起完成的。
            </p>


                <br/>
            <p>
                Github 链接: <a href="https://github.com/vincentlee9512/CISC340-Project-2" target="_blank ">Project Repository</a>
            </p>

            <br/>
            <h6>2018年 10月 17日：</h6>
            <h6>计算机系统结构：汇编程序与行为模拟器</h6>
            <p>
                （小组项目）在这个项目里，Lucy Post 和我一起创建了一个汇编语言程序和计算机行为模拟器。这两个程序都是用 C 语言开发的。
                汇编语言程序的目标是将汇编语言转换成行为模拟器的相应的机器代码（此处的汇编语言和机器代码都是经过教授自定义的）。
                行为模拟器的目标是执行汇编语言程序输入的机器代码，模拟出计算机在执行时的各种状态（行为）。
            </p>

            <p>
                我在这个项目中主要负责汇编语言程序的开发工作和Github仓库的部署。
            </p>

                <br/>
            <p>
                Github 链接: <a href="https://github.com/vincentlee9512/CISC340-Project-1" target="_blank ">Project Repository</a>
            </p>


            <br/>
            <h6>2018年 4月 27日: </h6>
            <h6>动态服务器: 电影百科</h6>
            <p>
              （小组项目）在这个项目里，Emily Meuer 和我一起创建了一个有关与查询电影和电视资讯（基于 IMDb）的动态服务器。这个项目包括一个与SQL数据库交互的动态服务器和一个简单的可以使用此服务器的网页。我主要负责编写服务器处理各种请求时需要的方程，处理服务器与数据库间的联系，各种数据格式化的方程，和前端的过滤器方程。
              <br/>
              -Github 链接: <a href="https://github.com/EmilyMeuer/movieWiki" target="_blank">MovieWiki Github Repository</a> <br/> <br/>
            </p>
    
            
    
            <br/>
            <h6>2018年 4月 6日: </h6>
            <h6>网页应用：空气质量检测</h6>
            <p>
              （小组项目）在这个项目中，Bobby Martin和我一起创建了一个基于地图的监测空气中含对人体有害物质的动态网页（实时数据）。我们用了两个开放的API， <a href="https://developers.google.com/maps/documentation/javascript/tutorial" target="_blank">Google Maps</a> 和 
              <a href="https://docs.openaq.org/" target="_blank">Open AQ Platform</a>，来搭建这个应用。我们还用了Angular.js和bootstrap框架来让这个网页应用用起来更加有响应。这个项目中，我主要负责了用Ajax原理在两个API中获取数据，结合并格式化数据，Angular.js的双向数据绑定，和过滤器方程。
              <br/>
              -网页应用链接: <a href="https://vincentlee9512.github.io/AQwebapp/" target="_blank" >AQwebapp</a> <br/>
              -Github 链接: <a href="https://github.com/vincentlee9512/AQwebapp" target="_blank">AQwebapp Github Repository</a>
            </p>
    
            <br/>
            <h6>2018年 3月 2日</h6>
            <h6>网页应用：待办清单</h6>
            <p>
              在这个项目中，我用原生的html+css+Javascript创建了一个待办清单的网页应用。这个网页还用了浏览器的本地储存来记录用户们的数据。这个项目的目的是练习原生的html+css+Javascript。

              <br/>
              -原生 Javascript 和 CSS: <a href="https://vincentlee9512.github.io/toDoListAndPhotoGallery/" target="_blank">https://vincentlee9512.github.io/toDoListAndPhotoGallery/</a>
              <br/>
              -在学习了各种前端框架之后，我用Angular.js和bootstrap重写了这个应用: <a href="https://vincentlee9512.github.io/todoList/" target="_blank">https://vincentlee9512.github.io/todoList/</a>
            </p>
    
            <br/>
            <h6>2017年 12月 13日: </h6>
            <h6>C++ 程序: 内存处理模拟器</h6>
            <p>
              在这个项目中，Tyler Green，Elena Ryan 和我一起创建了一个操作系统的内存处理模拟器。这个项目的目的是模拟操作系统中，数据和进程在内存的物理地址和虚拟地址中的各种变化过程。我主要负责数据的虚拟页面与部分物理页框，和所有数据的虚拟地址和物理地址的部署。
              <br/>
              -Github: <a href="https://github.com/ty2610/OS_Assignment_4" target="_blank" >https://github.com/ty2610/OS_Assignment_4</a>
            </p>
    
            <br/>
            <h6>2017年春:</h6>
            <h6>Java 程序: 局域网聊天应用</h6>
            <p>
              这个项目是我和几个学校里计算机科学社团里的朋友一起搭建的聊天应用。这个Java应用主要运用了Java里的多播技术来搭建局域网内的聊天应用。其中会用到Singleton 来从txt文件提取ip和端口等信息，而且会用到Caesar Cipher 来对字节进行加密。当两个人完全交换密码本之后，才能交换信息

              <br/>
    
              -Github: <a href="https://github.com/vincentlee9512/java_chat_app" target="_blank" >https://github.com/vincentlee9512/java_chat_app</a>
            </p>
          </div>
    </div>
  </div>
  <script src="js/popper.min.js"></script>
  <script src="js/jquery.min.js"></script>
  <script src="js/bootstrap.bundle.min.js"></script>
  <script src="js/script.js"></script>

</body>
</html>